# تقييم جودة الكود — Rakez ERP

تقييم مفصل لجودة الكود مع شرح **المخاطر** على التوسع، القوة، والصيانة، واقتراح **أفضل المعايير** للمشروع.

---

## ١. ملخص تنفيذي

| البعد           | التقييم   | ملاحظة مختصرة |
|-----------------|-----------|----------------|
| **الهيكل والمعمارية** | جيد      | فصل Controller → Service → Model؛ تناسق بين الوحدات |
| **الأمان**          | يحتاج تحسين | صلاحيات على المسارات؛ تسريب رسائل الاستثناءات في الإنتاج |
| **قابلية التوسع**   | متوسطة   | اعتماد على صلاحيات المسار فقط؛ نقص توحيد الاستجابات والتسجيل |
| **القوة والموثوقية** | جيد      | استخدام DB::transaction في الخدمات الحرجة؛ قفل الوحدات عند الحجز |
| **الصيانة**         | متوسطة   | خلط بين Form Request والتحقق داخل الكونترولر؛ نقص توحيد معالجة الأخطاء |

---

## ٢. المعمارية وهيكل الكود

### ٢.١ ما يعمل بشكل جيد

- **فصل الطبقات**: وجود نمط Controller → Service → Model في المبيعات، التسويق، المحاسبة، والائتمان.
- **Form Requests**: استخدام طلبات مخصصة (مثل `StoreBudgetDistributionRequest`) مع قواعد تحقق معقدة ومنطق موحد.
- **خدمات الأعمال**: المنطق التجاري في الخدمات (مثل `SalesReservationService`, `MarketingBudgetCalculationService`) وليس في الكونترولر.
- **استجابة API موحدة**: وجود `ApiResponse` (success, error, validationError, paginated) يعطي اتساقاً في شكل الاستجابة.

### ٢.٢ مخاطر التوسع والصيانة

| المخاطرة | الوصف | التأثير |
|----------|--------|---------|
| **عدم اتساق الاستجابة** | بعض الكونترولرات تُرجع `response()->json([...])` مباشرة (مثل `MarketingBudgetDistributionController`) والبعض يستخدم `ApiResponse::success/error`. | توسع الفريق أو إضافة وحدات جديدة قد يزيد الاختلاف؛ صعوبة توحيد التعامل من الواجهة الأمامية. |
| **تحقق داخل الكونترولر** | في `HrUserController` (store, update, toggleStatus) التحقق يتم عبر `$request->validate([...])` داخل الكونترولر. | تكرار القواعد عند إعادة استخدام نفس البيانات من مكان آخر؛ صيانة مزدوجة. |
| **غياب طبقة Repository** | الوصول إلى النماذج مباشرة من الكونترولر أحياناً (مثل `MarketingBudgetDistribution::where(...)` في `show`) أو من الخدمة. | عند تغيير مصدر البيانات أو إضافة كاش، سيتطلب تعديلات في أماكن متعددة. |

**توصيات:**

- توحيد جميع استجابات الـ API عبر `ApiResponse` (أو غيره) وعدم استخدام `response()->json([...])` مباشرة في الكونترولر.
- نقل كل قواعد التحقق الخاصة بـ HR (إنشاء/تحديث موظف، رفع ملفات) إلى Form Request مخصصة (مثل `StoreHrUserRequest`, `UpdateHrUserRequest`).
- اختياري: إدخال Repository فقط للكيانات الأساسية (مثل Contract, User, SalesReservation) عند الحاجة لاستعلامات معقدة أو كاش.

---

## ٣. الأمان

### ٣.١ ما يعمل بشكل جيد

- **المصادقة**: استخدام `auth:sanctum` للمسارات المحمية.
- **الصلاحيات**: middleware `permission:` (عبر `CheckDynamicPermission`) مطبقة على عدد كبير من المسارات (~265 استخدام)، مع دعم `hasEffectivePermission` للصلاحيات الديناميكية.
- **التحقق من المدخلات**: Form Requests تحد من القيم المسموحة (مثل `exists:marketing_projects,id`, `Rule::in(['employee','developer'])`).
- **النماذج**: استخدام `$fillable` في النماذج (مثل `User`) وعدم وجود `$guarded = []` يقلل خطر mass assignment.

### ٣.٢ مخاطر أمنية

| المخاطرة | الوصف | التأثير |
|----------|--------|---------|
| **تسريب رسائل الاستثناءات** | في عدة كونترولرات (مثل `MarketingBudgetDistributionController`, `ClaimFileController`, `ContractController`) يتم إرجاع `'error' => $e->getMessage()` أو `ApiResponse::error($e->getMessage(), 500)` في استجابة 500. | في الإنتاج قد تكشف رسائل الاستثناءات مسارات الملفات، أسماء الجداول، أو تفاصيل تقنية؛ مساعدة المهاجم في استكشاف النظام. |
| **الصلاحية على مستوى المسار فقط** | كثير من الـ endpoints تعتمد على صلاحية عامة (مثل `marketing.budgets.manage`) دون تحقق من أن المورد (مثل `distributionId` أو `projectId`) يخص سياق المستخدم. | إذا كانت الصلاحيات دقيقة جداً (مثلاً حسب مشروع) قد يصل مستخدم لموارد خارج نطاقه ما لم تُضف سياسات (Policies) أو تحققات إضافية. |
| **عدم وجود تحقق في Form Request** | في `StoreBudgetDistributionRequest` الدالة `authorize()` تُرجع `true`؛ الصلاحية معتمدة فقط على middleware المسار. | مقبول إذا كان middleware كافياً؛ لكن إضافة `authorize()` في الـ Request يعزز الدفاع في العمق ويسمح بفحص المورد (مثلاً أن المشروع يخص فريق المستخدم). |
| **استعلامات خام** | استخدام `DB::raw` و `selectRaw` في أماكن محدودة (إحصائيات، تجميعات). القيم المعطاة لهذه الاستعلامات من السياق الداخلي وليست من المستخدم مباشرة. | خطر منخفض حالياً؛ يجب تجنب تمرير أي مدخلات مستخدم داخل `DB::raw` أو `whereRaw` بدون ربط (binding) آمن. |

**توصيات:**

- في بيئة الإنتاج: عدم إرجاع `$e->getMessage()` أو تفاصيل الاستثناء في جسم الاستجابة؛ استخدام رسالة عامة (مثل "حدث خطأ داخلي") وتسجيل التفاصيل عبر `Log::error()`.
- توحيد معالجة الأخطاء في طبقة مركزية (مثلاً Exception Handler أو Middleware) لـ 500 حتى لا يعتمد المطور على تذكر عدم تسريب الرسائل في كل كونترولر.
- للموارد الحساسة (مثلاً توزيع ميزانية لمشروع معين): إضافة Policy أو تحقق في الـ Request أن المورد يخص المستخدم/الفريق/المشروع حسب نموذج الصلاحيات.

---

## ٤. القوة والموثوقية (Robustness)

### ٤.١ ما يعمل بشكل جيد

- **المعاملات (Transactions)**:
  - استخدام `DB::beginTransaction()` مع commit/rollback في خدمات حرجة مثل:
    - `SalesReservationService` (إنشاء حجز، إلغاء)
    - `AccountingDepositService`, `AccountingCommissionService`, `AccountingSalaryService`
    - `CreditFinancingService`, `TitleTransferService`, `ClaimFileService`
    - `ContractService`, `ContractUnitService`, `RegisterService`, وغيرها
- **منع الحجز المزدوج**: في `SalesReservationService::createReservation` استخدام `lockForUpdate()` على الوحدة قبل التحقق من الحجز النشط ثم الإنشاء.
- **ثوابت الحالة**: استخدام ثوابت (مثل `ReservationStatus::active()`) يقلل الأخطاء النصية ويُسهّل الصيانة.

### ٤.٢ مخاطر القوة والموثوقية

| المخاطرة | الوصف | التأثير |
|----------|--------|---------|
| **معاملات في الكونترولر** | في `AccountingConfirmationController` يوجد `DB::beginTransaction()` داخل الكونترولر. | المنطق المالي أفضل أن يكون داخل خدمة مع تعامل واحد مع الـ DB؛ الكونترولر يستدعي الخدمة فقط. |
| **معالجة الاستثناءات داخل الكونترولر** | في `MarketingBudgetDistributionController` يتم اصطياد `\InvalidArgumentException` و `\Exception` وإرجاع 422/500. الخدمة قد ترمي استثناءات أخرى (مثلاً عدم وجود مشروع). | تصنيف رموز HTTP قد يكون خاطئاً؛ والأفضل أن ترمي الخدمة استثناءات ذات معنى ويُترجم في طبقة واحدة (مثلاً Handler أو كونترولر أساسي). |
| **عدم وجود إعادة محاولة للعمليات الحرجة** | لا يوجد نمط واضح لإعادة المحاولة (retry) عند فشل مؤقت (مثلاً قفل DB أو شبكة). | في بيئة موزعة أو ضغط عالي قد يساعد إعادة المحاولة المحدودة على تقليل الأخطاء الظرفية. |

**توصيات:**

- نقل أي منطق يحتوي على `DB::beginTransaction()` من الكونترولر إلى خدمة (مثل `AccountingConfirmationService`) واستدعاء الخدمة من الكونترولر فقط.
- توحيد استثناءات الأعمال (مثلاً `DomainException` أو استثناءات مخصصة مثل `UnitAlreadyReservedException`) واستخدام Exception Handler أو قاعدة Controller لتحويلها إلى رموز HTTP ورسائل آمنة.
- للعمليات الحرجة الاختيارية: استخدام queue مع retry أو دالة مساعدة تعيد المحاولة لعدد محدود مع backoff.

---

## ٥. الصيانة وقابلية القراءة

### ٥.١ ما يعمل بشكل جيد

- **تسمية واضحة**: أسماء الخدمات والكونترولرات تعكس الوحدة والوظيفة (مثل `MarketingBudgetCalculationService`, `SalesReservationService`).
- **تعليقات PHPDoc**: وجود تعليقات على الدوال في كثير من الملفات.
- **ثوابت وEnums**: استخدام ثوابت للحالات يقلل "أرقام سحرية" ونصوص مبعثرة.

### ٥.٢ مخاطر الصيانة

| المخاطرة | الوصف | التأثير |
|----------|--------|---------|
| **تكرار قواميس النوع** | في `AccountingNotificationService` توجد قواميس مكررة للكلمات المفتاحية والعناوين (مثل `getTypeKeyword`, `getTitleForType`, `getTypeFromMessage`). | أي إضافة نوع إشعار جديد تتطلب تعديل عدة دوال؛ سهولة نسيان مكان. |
| **كونترولر سمين في HR** | `HrUserController::show` يبني مصفوفة `$data` يدوياً بحقول كثيرة. | أي إضافة/حذف حقل تتطلب تعديل الكونترولر؛ إمكانية نسيان إخفاء حقول حساسة (مثل IBAN). |
| **عدم وجود تسجيل (Logging)** | لا يوجد استخدام لـ `Log::` أو `logger()` في الكونترولرات التي تم فحصها. | صعوبة تتبع الأخطاء في الإنتاج أو مراجعة من قام بماذا دون الاعتماد على نظام خارجي فقط. |
| **نسخ ملف** | وجود `app/Services/Registration/register.php` بجانب `RegisterService.php` مع نفس المحتوى تقريباً (استخدام DB::beginTransaction في نفس الأسطر). | التباس مصدر الحقيقة وازدواجية في الصيانة. |

**توصيات:**

- توحيد قواميس أنواع الإشعارات في مكان واحد (مثلاً مصفوفة config أو كلاس ثابت) واستخدامها من `AccountingNotificationService`.
- استخدام **API Resources** (مثل `UserResource`) لـ `HrUserController::show` (وغيره) بدلاً من بناء المصفوفة يدوياً؛ يسهل إخفاء الحقول وإضافة شرطية.
- تسجيل الأخطاء الحرجة في الخدمات أو في Exception Handler: `Log::error('...', ['exception' => $e, 'context' => ...])`.
- حذف أو إهمال الملف المكرر `register.php` والاعتماد على `RegisterService` فقط.

---

## ٦. الاختبارات

### ٦.١ الوضع الحالي

- يوجد عدد جيد من الاختبارات (أكثر من 100 ملف اختبار) تشمل:
  - Feature: مبيعات، تسويق، محاسبة، ائتمان، HR، AI، عقود، تسجيل دخول، صلاحيات.
  - Unit: خدمات (مثل `MarketingBudgetCalculationService`, `AccountingDashboardService`)، استجابات، middleware، مساعدين.
- توجد اختبارات للصلاحيات (مثل `MarketingAccessTest`, `SalesAccessTest`, `AIAuthorizationTest`).

### ٦.٢ مخاطر تتعلق بالاختبارات

| المخاطرة | الوصف | التأثير |
|----------|--------|---------|
| **تغطية غير موحدة** | بعض الوحدات لديها تغطية أفضل (مثل AI، Marketing، Sales) والبعض قد يكون أقل. | تغييرات في مناطق غير مغطاة قد تكسر سلوكاً دون كشف. |
| **اعتماد على قاعدة بيانات/حالة** | الاختبارات Feature تعتمد على HTTP وربما قاعدة بيانات. | بدون توثيق واضح لـ seed أو factories قد تصبح الاختبارات هشة أو صعبة التشغيل. |

**توصية:**

- تشغيل تغطية الكود (مثلاً `phpunit --coverage-text` أو `--coverage-html`) دورياً وتحديد الوحدات الحرجة ذات التغطية المنخفضة ورفعها.
- توثيق متطلبات تشغيل الاختبارات (قاعدة بيانات اختبار، migrations، seed إن وجد) في README أو في دليل المطور.

---

## ٧. أفضل المعايير المقترحة (Checklist)

### ٧.١ طبقة العرض (Controllers / HTTP)

- [ ] جميع استجابات الـ API عبر كلاس موحد (مثل `ApiResponse`).
- [ ] عدم إرجاع رسالة الاستثناء الخام في بيئة الإنتاج (استخدام رسالة عامة + تسجيل).
- [ ] استخدام Form Request لكل endpoint يعدل أو ينشئ بيانات؛ تجنب `$request->validate()` داخل الكونترولر.
- [ ] عدم وضع منطق DB (مثل `DB::beginTransaction`) داخل الكونترولر؛ فقط استدعاء الخدمات.
- [ ] للموارد الحساسة: استخدام Policy أو `authorize()` في الـ Request بالإضافة إلى صلاحية المسار.

### ٧.٢ طبقة الأعمال (Services)

- [ ] أي عملية تعدل أكثر من جدول أو أكثر من كيان داخل `DB::transaction`.
- [ ] رمي استثناءات ذات معنى (مثلاً domain exceptions) بدلاً من رسائل عامة؛ المعالجة في طبقة واحدة.
- [ ] تجنب الوصول المباشر إلى `Request` داخل الخدمة؛ تمرير القيم أو DTO من الكونترولر.
- [ ] تسجيل الأخطاء الحرجة (على الأقل في catch قبل إعادة الرمي).

### ٧.٣ النماذج والأمان

- [ ] استخدام `$fillable` (أو قائمة بيضاء واضحة) في كل نموذج؛ عدم استخدام `$guarded = []` لفتح كل الحقول.
- [ ] عدم تمرير مدخلات المستخدم أبداً داخل `DB::raw` أو `whereRaw` بدون ربط آمن.

### ٧.٤ الصيانة والاتساق

- [ ] قواميس وقيم ثابتة (مثل أنواع الإشعارات) في مكان واحد (config أو Constant class).
- [ ] استخدام API Resources للمخرجات المعقدة بدلاً من بناء مصفوفات يدوياً في الكونترولر.
- [ ] إزالة الملفات أو الأكواد المكررة (مثل `register.php` إذا كان نسخة من RegisterService).

### ٧.٥ التشغيل والإنتاج

- [ ] `APP_DEBUG=false` وعدم كشف تفاصيل الأخطاء للمستخدم.
- [ ] تفعيل التسجيل (logging) لأخطاء 500 والعمليات الحرجة.
- [ ] مراجعة دورية لصلاحيات المسارات والتأكد من عدم وجود مسارات حساسة بدون صلاحية.

---

## ٨. الخلاصة

المشروع يتبع هيكلاً واضحاً (Controller → Service → Model) ويستخدم معاملات قاعدة البيانات وقفل الصفوف في العمليات الحرجة، مع نظام صلاحيات على المسارات. **أهم نقاط التحسين**: توحيد الاستجابات ومعالجة الأخطاء (بدون تسريب رسائل الاستثناء في الإنتاج)، نقل التحقق من الكونترولر إلى Form Requests، توحيد التسجيل والثوابت، واستخدام Resources للمخرجات المعقدة. تطبيق قائمة "أفضل المعايير" أعلاه يقلل مخاطر التوسع ويحسّن القوة والصيانة على المدى الطويل.

---

*تم إعداد التقييم بناءً على عينة من الكود في `rakez-erp` (Controllers، Services، Models، Requests، Routes، Tests).*
